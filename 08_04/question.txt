Math.nextDown(x)メソッドは、何らかのランダムな処理がxに正確に一致した場合に、xよりも次に小さな浮動小数点を返します。
これにより、返された値がxより小さいことが保証されます。
これは本当に保証できるのでしょうか。
double x = 1 - generator.nextDown() を考えてみてください。
このgeneratorは、java.util.Randomのインスタンスです。
rが、1になることはあるでしょうか。
すなわち、generator.nextDouble()が0を生成できるでしょうか。
ドキュメントによれば、それは0を含み、1未満の値を生成できるとなっています。
しかし、2^32個の浮動小数点数が存在することを考慮すると、0を得ることはあるのでしょうか。
実際、0を得ます。
乱数生成器は、次のシードをnext(s)=s・m+a%N として計算します。
ここで、m=25214903917、a=11、N=2^48です。mモジュロNの逆はv=246154705703781です。
そして、結果として、シードの前の値をprev(s)=(s-a)/v%Nとして計算することができます。
doubleを生成するために２つの乱数が生成されて、毎回、トップの26ビットと27ビットが使用されます。
sが0の場合、next(s)は11であり、それが私達が得たいものです。
すなわち、２つの連続する数字の上位ビットが0です。
ここで、逆にやりなおして、s=prev(prev(prev(0)))から始めましょう。
Randomのコンストラクタはs=~(initialSedd^m)を設定するので、s=(prev(prev(prev(0)))^m=164311266871034を提供すると、
nextDoubleの2回目の呼び出し後に0となります。
しかし、それはあまりにも明白です。
100万個の前の値を、もちろん、ストリームを使用して生成し、最小のシードを見つけなさい。
ヒント：nextDoubleを376040回呼び出した後に0を得ます。



